# HTTP 메서드
> 요약 : HTTP API를 만들려면 행위에 따라 만드는 것이 아닌 리소스에 따라 만들어야 한다. 리소스에 따라 만들기만 하면, 각각의 행위는 어떻게 구별해야 하냐가 문제인데, 이것은 HTTP 메서드를 통해 각각의 기능들을 구별한다.

## HTTP API를 만들어보자
- 회원 정보 관리 API를 만들어본다고 가정하면, 우린 흔히 '회원 목록 조회, 회원 조회, 회원 등록, 회원 수정, 회원 삭제'로 구분하여
-  각각 'read-member-list, read-member-by-id, create-member, update-member, delete-member'로 URI를 설계할 생각을 했을 것이다.
-  하지만 이것은 잘못된 방식이다. 가장 중요한 것은 **리소스 식별**이다.
-  그렇다면 리소스는 무엇인가? 리소스는 '회원 목록 조회, 회원 조회, 회원 등록, 회원 수정, 회원 삭제'에서 바로 **회원**이라는 개념 자체이다.
-  그렇기 때문에 회원 리소스를 URI에 매핑해야 한다. 각각 'members, members/{id}, members/{id}, members/{id}, members/{id}'와 같이 말이다.
-  (이 때 계층 구조상 상위인 회원을 컬렉션(조회,등록 등등의)으로 보고, member가 아닌 복수단어인 **members**를 사용하길 권장한다.)
-  위의 URI의 생김새는 같은데 이를 통해 조회인지 등록인지 수정인지 삭제인지는 어떻게 구별할 수 있을까?
-  **URI는 행위를 구별하는게 아니라 리소스만 구별**하고, **행위인 조회,등록,수정,삭제는 HTTP 메서드를 통해 구별**한다.
## HTTP 메서드 - GET, POST
- ### HTTP 메서드 종류
  - **주요 메서드**
    - GET : 리소스 조회
    - POST : 요청 데이터 처리, 주로 등록에 사용
    - PUT : 리소스를 대체, 해당 리소스가 없으면 생성 (a.k.a. 덮어쓰기)
    - PATCH : 리소스 부분 변경
    - DELETE : 리소스 삭제
  - **기타 메서드** -> 이런게 있다 정도만 알아둬도 되는데 특히 CONNECT와 TRACE는 잘 쓰이지 X
    - HEAD : GET과 동일하지만 메시지 부분을 제외하고, 상태 줄과 헤터만 반환
    - OPTION : 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명(주로 CORS에서 사용-CORS란? Cross-Origin Resource Sharing의 약자로 한 출처에 있는 자원에서 다른 출처에 있는 자원에 접근 가능하도록 하는 메커니즘이다)
    - CONNECT : 대상 리소스로 식별되는 서버에 대한 터널을 설정
    - TRACE : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행
- GET
  - 서버에 전달하고 싶은 데이터를 **쿼리**를 통하여 전달함(메시지 바디를 통해 전달할 수도 있지만 지원하지 않는 곳이 많아 권장X)
- POST
  - **메시지 바디**를 통해 데이터 전달 후 서버는 그 요청 데이터를 처리하는 모든 기능을 수행한다.
  - 주로 신규 리소스 등록이나 프로세스 처리에 사용된다.
  - 이 POST는 기능별로 처리법이 다 다르기 때문에 리소스마다 따로 정해야 한다.
  - 최대한 GET을 사용하는게 좋은데, GET을 사용하지 못하는 경우가 종종 있다. 예로 들자면 JSON으로 조회 데이터를 넘겨야 하는데 가공을 해서 넘겨야 해서 GET메서드를 사용하기 어려운 경우처럼 말이다.
## HTTP 메서드 - PUT, PATCH, DELETE
- PUT
  - 이전에 POST는 POST /members HTTP/1.1로 요청대상에 대한 정확한 리소스가 적혀 있지 않았다.
  - PUT은 이와 다르게 PUT /members/100 HTTP/1.1로 **클라이언트가 리소스 위치를 알고 URI를 지정한다**는 차이점을 가진다.
  - 주의할 점 : 리소스를 완전히 대체하기 때문에 서버가 age와 username에 대한 데이터를 갖고 있었을 때, age 데이터만 보내면 username 필드는 **사라진다**.
- PATCH
  - PUT은 완전대체였다면, PATCH는 부분대체이다.
  - 그렇기 때문에 PUT의 주의할 점에 언급했던 상황과 똑같은 상황이였을 때 PATCH는 username 필드는 **사라지지 않고** age 데이터만 대체된다.
  - 클라이언트가 리소스를 식별
- DELETE
  - 클라이언트가 리소스를 식별

## HTTP 메서드의 속성
- 안전(Safe Methods)
  - 호출해도 리소스를 변경하지 않는 것 ex) GET, HEAD
- 멱등(Idempotent Methods)
  - 한 번 호출하든 여러 번 호출하든 결과가 똑같이 나오는 것
  - GET, PUT, DELETE 는 반복해서 똑같은 호출을 한다고 하면, 첫번째 호출했던 것과 똑같은 효과가 보이는 반면,(멱등O)
  - POST는 반복해서 똑같은 호출을 하면, 배달주문을 1번 넣은 것이 2~4번 넣은 것과 다른 것과 같이 중복하는 효과가 있다.(멱등X)
  - **단, 멱등은 재요청 중간에 다른 곳에서 리소스를 변경한다는 것까지 고려하지 않는다!**
- 캐시가능(Cacheable Methods)
  - GET, HEAD, POST, PATCH 모두 캐시가능하지만, 실제로 POST와 PATCH는 본문 내용까지 캐시 키로 고려해야 하는데 구현이 쉽지 않기 때문에 GET과 HEAD 정도만 캐시로 사용한다.
